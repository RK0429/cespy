#!/usr/bin/env python
# coding=utf-8

"""LTSpice log file parsing and analysis utilities.

This module provides classes and functions for reading, parsing, and analyzing
LTSpice simulation log files, extracting measurement data, step information,
and error analysis.

Copyright (c) 2023 Nuno Brum
License: GPL-3.0
"""

# Enable postponed evaluation of annotations for forward references
from __future__ import annotations

import argparse
import dataclasses
import logging
import os
import os.path
import re
import sys
from typing import Any, Dict, Iterator, List, Optional, TypeVar, Union

from ..utils.detect_encoding import detect_encoding
from .logfile_data import LogfileData, try_convert_value

# -------------------------------------------------------------------------------
#
#  ███████╗██████╗ ██╗ ██████╗███████╗██╗     ██╗██████╗
#  ██╔════╝██╔══██╗██║██╔════╝██╔════╝██║     ██║██╔══██╗
#  ███████╗██████╔╝██║██║     █████╗  ██║     ██║██████╔╝
#  ╚════██║██╔═══╝ ██║██║     ██╔══╝  ██║     ██║██╔══██╗
#  ███████║██║     ██║╚██████╗███████╗███████╗██║██████╔╝
#  ╚══════╝╚═╝     ╚═╝ ╚═════╝╚══════╝╚══════╝╚═╝╚═════╝
#
# Name:        ltsteps.py
# Purpose:     Process LTSpice output files and align data for usage in a spread-
#              sheet tool such as Excel, or Calc.
#
# Author:      Nuno Brum (nuno.brum@gmail.com)
#
# Licence:     refer to the LICENSE file
# -------------------------------------------------------------------------------

__author__ = "Nuno Canto Brum <me@nunobrum.com>"
__copyright__ = "Copyright 2023, Fribourg Switzerland"

_logger = logging.getLogger("cespy.LTSteps")

T = TypeVar("T")


def reformat_LTSpice_export(export_file: str, tabular_file: str) -> None:
    """Reads an LTSpice File Export file and writes it back in a format that is more
    convenient for data treatment.

    When using the "Export data as text" in the raw file menu the data is already
    exported in a tabular format. However, if steps are being used, the step information
    doesn't appear on the table.  Instead the successive STEP runs are stacked on one
    after another, separated by the following text:

    .. code-block:: text

    Step Information: Ton=400m  (Run: 2/2)

    What would be desirable would be that the step number (Run number) and the STEP
    variable would be placed within the columns.  This allows, for example, using Excel
    functionality known as Pivot Tables to filter out data, or some other database
    selection function. The tab is chosen as separator because it is normally compatible
    with pasting data into Excel.

    :param export_file: Filename of the .txt file generated by the "Export Data as Text"
    :type export_file: str
    :param tabular_file: Filename of the tab separated values (TSV) file that
    :type tabular_file: str
    :return: Nothing
    """
    encoding = detect_encoding(export_file)
    with open(export_file, "r", encoding=encoding) as fin, open(
        tabular_file, "w", encoding=encoding
    ) as fout:
        headers = fin.readline()
        # writing header
        go_header = True
        run_no = (
            "0"  # Changed from int to str as the regex will return a string
        )
        param_values = ""
        regx = re.compile(
            r"Step Information: ([\w=\d\. \-]+) +\((?:Run|Step): (\d*)/\d*\)\n"
        )
        for line in fin:
            if line.startswith("Step Information:"):
                match = regx.match(line)
                if match:
                    step, run_no = match.groups()
                    params = []
                    for param in step.split():
                        params.append(param.split("=")[1])
                    param_values = "\t".join(params)

                    if go_header:
                        header_keys = []
                        for param in step.split():
                            header_keys.append(param.split("=")[0])
                        param_header = "\t".join(header_keys)
                        msg = f"Run\t{param_header}\t{headers}"
                        fout.write(msg)
                        _logger.debug(msg)
                        go_header = False
            else:
                fout.write(f"{run_no}\t{param_values}\t{line}")


class LTSpiceExport:
    """Opens and reads LTSpice export data when using the "Export data as text" in the
    File Menu on the waveform window.

    The data is then accessible by using the following attributes implemented in this
    class.

    :property headers: list containing the headers on the exported data
    :property dataset: dictionary in which the keys are the the headers and the export file and
        the values are lists. When reading STEPed data, a new key called 'runno' is
        added to the dataset.

    **Examples**

    ::

        export_data = LTSpiceExport("export_data_file.txt")
        for value in export_data.dataset['i(v1)']:
            print(f"Do something with this value {value}")

    :param export_filename: path to the Export file.
    :type export_filename: str
    """

    def __init__(self, export_filename: str):
        self.encoding = detect_encoding(export_filename)
        with open(export_filename, "r", encoding=self.encoding) as fin:
            file_header = fin.readline()

            self.headers = file_header.split("\t")
            # Set to read header
            go_header = True

            curr_dic: Dict[str, Any] = {}
            self.dataset: Dict[str, List[Any]] = {}

            regx = re.compile(
                r"Step Information: ([\w=\d\. -]+) +\(Run: (\d*)/\d*\)\n"
            )
            for line in fin:
                if line.startswith("Step Information:"):
                    match = regx.match(line)
                    if match:
                        step, run_no = match.groups()
                        curr_dic["runno"] = run_no
                        for param in step.split():
                            key, value = param.split("=")
                            curr_dic[key] = try_convert_value(value)

                        if go_header:
                            go_header = False  # This is executed only once
                            for key in self.headers:
                                # Initializes an empty list
                                self.dataset[key.lower()] = []

                            for key in curr_dic:
                                # Initializes an empty list
                                self.dataset[key.lower()] = []

                else:
                    values = line.split("\t")

                    for key, value in curr_dic.items():
                        self.dataset[key.lower()].append(value)

                    for i, val in enumerate(values):
                        self.dataset[self.headers[i].lower()].append(
                            try_convert_value(val)
                        )


@dataclasses.dataclass
class HarmonicData:
    """Container for harmonic analysis data from Fourier decomposition."""

    harmonic_number: int
    frequency: float
    fourier_component: float
    normalized_component: float
    phase: float
    normalized_phase: float
    # units: dict = dataclasses.field(default_factory=dict)

    @classmethod
    def from_line(cls, line: str) -> HarmonicData:
        """Create a HarmonicData instance from a log file line.

        Args:
            line: A line from the harmonics table in the log file

        Returns:
            HarmonicData instance with parsed values
        """
        tokens = line.split()
        harmonic_number = int(tokens[0])
        frequency = float(tokens[1])
        fourier_component = float(tokens[2])
        normalized_component = float(tokens[3])
        phase = float(tokens[4].rstrip("°"))
        normalized_phase = float(tokens[5].rstrip("°"))
        return cls(
            harmonic_number,
            frequency,
            fourier_component,
            normalized_component,
            phase,
            normalized_phase,
        )


@dataclasses.dataclass
class FourierData:
    """Container for Fourier analysis results from signal decomposition."""

    signal: str
    n_periods: int
    dc_component: float
    phd: float  # Partial Harmonic Distortion
    thd: float  # Total Harmonic Distortion
    harmonics: List[HarmonicData]
    step: int

    @property
    def fundamental(self) -> float:
        """Get the fundamental frequency from the first harmonic."""
        return self.harmonics[0].frequency

    def __getitem__(self, item: int) -> HarmonicData:
        return self.harmonics[item]

    def __iter__(self) -> Iterator[HarmonicData]:
        return iter(self.harmonics)

    def __len__(self) -> int:
        return len(self.harmonics)


class LTSpiceLogReader(LogfileData):
    """Reads an LTSpice log file and retrieves the step information if it exists. The
    step information is then accessible by using the 'stepset' property of this class.
    This class is intended to be used together with the RawRead to retrieve the runs
    that are associated with a given parameter setting.

    This class constructor only reads the step information of the log file. If the
    measures are needed, then the user should call the get_measures() method.

    :property stepset: dictionary in which the keys are the variables that were STEP'ed
        during the simulation and the associated value is a list representing the
        sequence of assigned values during simulation.

    :property headers: list containing the headers on the exported data. This is only
        populated when the *read_measures* optional parameter is set to False.

    :property dataset: dictionary in which the keys are the headers and the export file
        and the values are lists. This is information is only populated when the
        *read_measures* optional parameter is set to False.

    :param log_filename: path to the Export file.
    :type log_filename: str
    :param read_measures: Optional parameter to skip measuring data reading.
    :type read_measures: boolean
    :param step_set: Optional parameter to provide the steps from another file. This is
        used to process .mout files.
    :type step_set: dict
    """

    def __init__(
        self,
        log_filename: str,
        read_measures: bool = True,
        step_set: Optional[Dict[str, List[Any]]] = None,
        encoding: Optional[str] = None,
    ):
        super().__init__(step_set)
        self.logname = log_filename
        self.fourier: Dict[str, List[FourierData]] = {}
        if encoding is None:
            self.encoding = detect_encoding(
                log_filename,
                r"^((.*\n)?Circuit:|([\s\S]*)--- Expanded Netlist ---)",
            )
        else:
            self.encoding = encoding

        # Preparing a stepless measurement read regular expression
        # there are only measures taken in the format parameter: measurement
        # A few examples of readings
        # vout_rms: RMS(v(out))=1.41109 FROM 0 TO 0.001  => Interval
        # vin_rms: RMS(v(in))=0.70622 FROM 0 TO 0.001  => Interval
        # gain: vout_rms/vin_rms=1.99809 => Parameter
        # vout1m: v(out)=-0.0186257 at 0.001 => Point
        # fcut: v(vout)=vmax/sqrt(2) AT 252.921
        # fcutac=8.18166e+006 FROM 1.81834e+006 TO 1e+007 => AC Find
        # Computation
        regx = re.compile(
            # r"^(?P<name>\w+)(:\s+.*)?=(?P<value>[\d(inf)\.E+\-\(\)dB,°]+)"
            # r"(( FROM (?P<from>[\d\.E+-]*) TO (?P<to>[\d\.E+-]*))|"
            # r"( at (?P<at>[\d\.E+-]*)))?",
            r"^(?P<name>\w+)(:\s+.*)?=(?P<value>[\d(inf)E+\-\(\)dB,°(-/\w]+)( FROM"
            r" (?P<from>[\d\.E+-]*) TO (?P<to>[\d\.E+-]*)|( at (?P<at>[\d\.E+-]*)))?",
            re.IGNORECASE,
        )

        _logger.debug("Processing LOG file: %s", log_filename)
        with open(log_filename, "r", encoding=self.encoding) as fin:
            line = fin.readline()
            # init variables, just in case. Not needed really, but helps
            # debugging
            signal: Optional[str] = None
            n_periods: Union[int, float] = 0
            dc_component: float = 0.0

            while line:
                if len(line.strip()) == 0:
                    # skip empty lines
                    pass
                elif line.startswith("N-Period"):
                    # Read number of periods
                    n_periods_str = line.strip("\r\n").split("=")[-1].strip()
                    if n_periods_str == "all":
                        n_periods = -1
                    else:
                        # Now it's a float, which is compatible with the
                        # expected type
                        n_periods = float(n_periods_str)
                elif line.startswith("Fourier components of"):
                    # Read signal name
                    line = line.strip("\r\n")
                    signal = line.split(" of ")[-1].strip()
                elif line.startswith("DC component:"):
                    # Read DC component
                    line = line.strip("\r\n")
                    dc_component = float(line.split(":")[-1].strip())
                elif line.startswith("Harmonic"):
                    # Skip next header line
                    fin.readline()
                    # Read Harmonics table
                    phd: Optional[float] = None
                    thd: Optional[float] = None
                    harmonics: List[HarmonicData] = []
                    while True:
                        line = fin.readline().strip("\r\n")
                        if line.startswith("Total Harmonic"):
                            # Find THD
                            match = re.search(r"\d+.\d+", line)
                            if match:  # Check if match exists
                                thd = float(match.group())
                        elif line.startswith("Partial Harmonic"):
                            # Find PHD
                            match = re.search(r"\d+.\d+", line)
                            if match:  # Check if match exists
                                phd = float(match.group())
                        elif line == "":
                            # End of the table
                            break
                        else:
                            harmonics.append(HarmonicData.from_line(line))

                    if (
                        signal is not None
                        and phd is not None
                        and thd is not None
                    ):
                        fourier_data = FourierData(
                            signal,
                            (
                                int(n_periods)
                                if isinstance(n_periods, float)
                                else n_periods
                            ),
                            dc_component,
                            phd,
                            thd,
                            harmonics,
                            self.step_count - 1,
                        )
                        if signal in self.fourier:
                            self.fourier[signal].append(fourier_data)
                        else:
                            self.fourier[signal] = [fourier_data]

                elif line.startswith(".step"):
                    self.step_count += 1
                    tokens = line.strip("\r\n").split(" ")
                    for tok in tokens[1:]:
                        lhs, rhs = tok.split("=")
                        # Try to convert to int or float
                        converted_rhs = try_convert_value(rhs)
                        lhs = lhs.lower()
                        ll = self.stepset.get(lhs, None)
                        if ll:
                            ll.append(converted_rhs)
                        else:
                            self.stepset[lhs] = [converted_rhs]

                elif line.startswith("Measurement:"):
                    if not read_measures:
                        fin.close()
                        return
                    break  # Jumps to the section that reads measurements

                if self.step_count == 0:  # then there are no steps,
                    match = regx.match(line)
                    if match:
                        # Get the data
                        dataname = match.group("name")
                        if match.group("from"):
                            headers = [
                                dataname,
                                dataname + "_FROM",
                                dataname + "_TO",
                            ]
                            measurements = [
                                match.group("value"),
                                match.group("from"),
                                match.group("to"),
                            ]
                        elif match.group("at"):
                            headers = [dataname, dataname + "_at"]
                            measurements = [
                                match.group("value"),
                                match.group("at"),
                            ]
                        else:
                            headers = [dataname]
                            measurements = [match.group("value")]
                        self.measure_count += 1
                        for k, title in enumerate(headers):
                            self.dataset[title.lower()] = [
                                try_convert_value(measurements[k])
                            ]  # need to be a list for compatibility
                line = fin.readline()

            meas_name: Optional[str] = None

            headers = []  # Initializing an empty parameters
            measurements = []
            while line:
                line = line.strip("\r\n")
                if line.startswith("Measurement: "):
                    if meas_name:  # If previous measurement was saved
                        # store the info
                        if measurements:
                            _logger.debug(
                                "Storing Measurement %s (count %d)",
                                meas_name,
                                len(measurements),
                            )
                            self.measure_count += len(measurements)
                            for k, title in enumerate(headers):
                                if title is None:
                                    continue
                                key = title.lower()
                                self.dataset[key] = [
                                    measure[k] for measure in measurements
                                ]
                        headers = []
                        measurements = []
                    # text which is after "Measurement: ". len("Measurement: ")
                    # -> 13
                    meas_name = line[13:]
                    _logger.debug("Reading Measurement %s", line[13:])
                else:
                    tokens = line.split("\t")
                    if len(tokens) >= 2:
                        try:
                            # This instruction only serves to trigger the
                            # exception
                            int(tokens[0])
                            meas = tokens[1:]  # remove the first token
                            measurements.append(try_convert_value(meas))
                            self.measure_count += 1
                        except ValueError:
                            if len(tokens) >= 3 and (
                                tokens[2] == "FROM" or tokens[2] == "at"
                            ):
                                if meas_name is not None:
                                    tokens[2] = meas_name + "_" + tokens[2]
                            if len(tokens) >= 4 and tokens[3] == "TO":
                                if meas_name is not None:
                                    tokens[3] = meas_name + "_TO"
                            headers = [meas_name] + tokens[2:]
                            measurements = []
                    else:
                        _logger.debug("->" + line)

                line = fin.readline()  # advance to the next line

            # storing the last data into the dataset
            if meas_name:
                _logger.debug(
                    "Storing Measurement %s (count %d)",
                    meas_name,
                    len(measurements),
                )
            if measurements:
                self.measure_count += len(measurements)
                for k, title in enumerate(headers):
                    if title is None:
                        continue
                    key = title.lower()
                    self.dataset[key] = [
                        measure[k] for measure in measurements
                    ]

            _logger.info(
                "Identified %d steps, read %d measurements",
                self.step_count,
                self.measure_count,
            )

    def export_data(
        self,
        export_file: str,
        encoding: Optional[str] = None,
        append_with_line_prefix: Optional[str] = None,
        value_separator: str = "\t",
        line_terminator: str = "\n",
    ) -> None:
        """Aside from exporting the data, it also exports fourier data if it exists."""
        super().export_data(
            export_file,
            encoding,
            append_with_line_prefix,
            value_separator,
            line_terminator,
        )

        fourier_export_file = os.path.splitext(export_file)[0] + "_fourier.txt"
        if self.fourier:
            with open(fourier_export_file, "w", encoding=encoding) as fout:
                if self.step_count > 0:
                    fout.write("\t".join(self.stepset.keys()) + "\t")
                fout.write(
                    "Signal\tN-Periods\tDC"
                    " Component\tFundamental\tN-Harmonics\tPHD\tTHD\n"
                )
                for signal in self.fourier:
                    if self.step_count > 0:
                        for step_no in range(self.step_count):
                            step_values = [
                                f"{values[step_no]}"
                                for step, values in self.stepset.items()
                            ]
                            for analysis in self.fourier[signal]:
                                if analysis.step == step_no:
                                    fout.write("\t".join(step_values) + "\t")
                                    if analysis.n_periods < 1:
                                        n_periods_str = "all"
                                    else:
                                        n_periods_str = str(analysis.n_periods)
                                    fout.write(
                                        f"{signal}\t"
                                        f"{n_periods_str}\t"
                                        f"{analysis.dc_component}\t"
                                        f"{analysis.fundamental}\t"
                                        f"{len(analysis)}\t"
                                        f"{analysis.phd}\t"
                                        f"{analysis.thd}\n"
                                    )
                    else:
                        for analysis in self.fourier[signal]:
                            if analysis.n_periods == -1:
                                n_periods_str = "all"
                            else:
                                n_periods_str = str(analysis.n_periods)
                            fout.write(
                                f"{signal}\t"
                                f"{n_periods_str}\t"
                                f"{analysis.dc_component}\t"
                                f"{analysis.fundamental}"
                                f"\t{len(analysis)}\t"
                                f"{analysis.phd}\t"
                                f"{analysis.thd}\n"
                            )
                fout.write("\n\nHarmonic Analysis\n")
                fout.write("\t".join(self.stepset.keys()) + "\t")
                fout.write(
                    "Signal\tN-Periods\tHarmonic\tFrequency\t"
                    "Fourier\tNormalized\tPhase\tNormalized\n"
                )
                for signal, analyses in self.fourier.items():
                    for analysis in analyses:
                        if self.step_count > 0:
                            for step_no in range(self.step_count):
                                if analysis.step == step_no:
                                    step_values = [
                                        f"{self.stepset[step][step_no]}"
                                        for step in self.stepset
                                    ]
                                    for harmonic in analysis:
                                        fout.write(
                                            "\t".join(step_values) + "\t"
                                        )
                                        fout.write(
                                            f"{signal}\t"
                                            f"{analysis.n_periods}\t"
                                            f"{harmonic.harmonic_number}\t"
                                            f"{harmonic.frequency}\t"
                                            f"{harmonic.fourier_component}\t"
                                            f"{harmonic.normalized_component}\t"
                                            f"{harmonic.phase}\t"
                                            f"{harmonic.normalized_phase}\n"
                                        )
                        else:
                            for harmonic in analysis:
                                fout.write(
                                    f"{signal}\t"
                                    f"{analysis.n_periods}\t"
                                    f"{harmonic.harmonic_number}\t"
                                    f"{harmonic.frequency}\t"
                                    f"{harmonic.fourier_component}\t"
                                    f"{harmonic.normalized_component}\t"
                                    f"{harmonic.phase}\t"
                                    f"{harmonic.normalized_phase}\n"
                                )
                fout.write("\n")


def main() -> None:
    """Command-line interface for processing LTSpice log files."""

    def valid_extension(filename: str) -> bool:
        """Check if the filename has a valid extension."""
        return filename.endswith((".txt", ".log", ".mout"))

    parser = argparse.ArgumentParser(
        description="Process LTSpice log files and align data for usage in spreadsheet tools"
    )
    parser.add_argument(
        "filename",
        nargs="?",
        help=(
            "Log file to process (.txt, .log, or .mout). If not provided, "
            "uses the most recent valid file."
        ),
    )
    parser.add_argument(
        "--last",
        action="store_true",
        help="Use the most recently modified valid file in the current directory",
    )

    args = parser.parse_args()

    filename = args.filename

    if not filename or args.last:
        # Find the most recent valid file
        newer_date = 0
        for f in os.listdir():
            if valid_extension(f):
                date = os.path.getmtime(f)
                if date > newer_date:
                    newer_date = date
                    filename = f

    if filename is None:
        print("File not found")
        print(
            "This tool only supports the following extensions: .txt, .log, .mout"
        )
        sys.exit(1)

    if not valid_extension(filename):
        print(f"Invalid extension in filename '{filename}'")
        print(
            "This tool only supports the following extensions: .txt, .log, .mout"
        )
        sys.exit(1)

    # Determine output filename
    if filename.endswith(".txt"):
        fname_out = filename[:-3] + "tsv"
    elif filename.endswith(".log"):
        fname_out = filename[:-3] + "tlog"
    elif filename.endswith(".mout"):
        fname_out = filename[:-4] + "tmout"
    else:
        fname_out = filename + ".tsv"

    print(f"Processing: {filename}")
    print(f"Output: {fname_out}")

    try:
        # Process the log file
        log_reader = LTSpiceLogReader(filename)

        # Export step data if available
        if log_reader.step_count > 0:
            print(f"Found {log_reader.step_count} steps")
            with open(fname_out, "w", encoding="utf-8") as fout:
                log_reader.export_data(fout)
            print(f"Data exported to {fname_out}")
        else:
            print("No step data found in log file")

    except (OSError, IOError, ValueError) as e:
        print(f"Error processing file: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
